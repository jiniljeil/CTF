package main

import (
	"crypto/rand"
	"encoding/hex"
	"testing"
	"time"
)

const numTests = 20

// TestGenerateSecret checks whether a secret generated by generateSecret is then
// correctly parsed by parseSecret.
func TestGenerateSecret(t *testing.T) {
	testCases := []struct{ isAdmin bool }{{true}, {false}}
	for _, tc := range testCases {
		for i := 0; i < numTests; i++ {
			expirationTime := time.Now().Add(SECRET_EXPIRATION_TIME).Unix()
			secret := generateSecret(tc.isAdmin, uint64(expirationTime))
			if len(secret) != SECRET_LEN {
				t.Errorf("len(%q) == %v, expected: %v", secret, len(secret), SECRET_LEN)
			}
			valid, isAdmin := parseSecret(secret)
			if !valid || isAdmin != tc.isAdmin {
				t.Errorf("parseSecret(generateSecret(%v)) == (%v, %v), expected (%v, %v)",
					tc.isAdmin, valid, isAdmin, true, tc.isAdmin)
			}
		}
	}
}

// TestGenerateSecretInThePast checks that tokens with expiration time in the past
// are invalid.
func TestGenerateSecretInThePast(t *testing.T) {
	for i := 0; i < numTests; i++ {
		expirationTime := time.Now().Add(-1 * time.Second).Unix()
		secret := generateSecret(false, uint64(expirationTime))
		if len(secret) != SECRET_LEN {
			t.Errorf("len(%q) == %v, expected: %v", secret, len(secret), SECRET_LEN)
		}
		valid, isAdmin := parseSecret(secret)
		if valid || isAdmin {
			t.Errorf("parseSecret(generateSecret(%v)) == (%v, %v), expected (%v, %v)",
				false, valid, isAdmin, false, false)
		}
	}

}

// TestParseSecretRandom checks whether giving random tokens to parseSecret returns
// valid == false.
func TestParseSecretRandom(t *testing.T) {
	for i := 0; i < numTests; i++ {
		r := make([]byte, SECRET_LEN)
		rand.Read(r)
		secret := hex.EncodeToString(r)
		valid, isAdmin := parseSecret(secret)
		if valid || isAdmin {
			t.Errorf("parseSecret(%v) == (%v, %v), expected (%v, %v)",
				secret, valid, isAdmin, false, false)
		}
	}
}
