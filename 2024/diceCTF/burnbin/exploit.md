burnbin solution:
1. uploading files as .png or .jpg have no mimetype (old version of fastify static) so they are mime sniffed (no xcto) and you can upload arb html / css
2. use technique from modernblog (clobber defaultView) and upload arb html that react router thinks is a target path. this lets us add custom html onto any page of the react app we want
3. now, we need to leak both the flag post id and username. we do this with css injection and iframes
4. we can use css to change the width/height of an iframe, and since there is no frame-src, we can point it to our own domain and read these values
5. i use window.open to get a window ref, then reading w.frames[0].innerWidth repeatedly
6. the only issue is, how do we leak the entire id if on every refresh the post ids change?
7. lets use the classic css recursive import (with a twist)
8. the issue with recursive import is that you need to import from a server you control. you need this bc you need the next css file request to stop responding until you leak the previous data so you know what css to send. but style-src is self, so we cant stall the next css file - or can we?
9. my solution: lets abuse the connection pool! if we  block every socket on another tab, we can stop the css from importing until we are ready, and we unblock and reblock the socket pool at will
10. this allows us to control the time at which the next css file is uploaded, essentially letting us recreate the recursive css technique even when we dont control the target server!
11. this is a little complicated, we need to remove type module from script tag so it doesnt block, as well as move it to body. in addition we have to start the initial css req in a style tag (which is why unsafe-inline is there), otherwise it blocks
12. we also need to create a “buffer” of empty css files that just request another one so we can account for the initial api requests (as they happen in tandem with the css requests)
13. with this you can leak the post id
14. now to leak the username, you do the same technique but need to stop the image from deleting
15. use a csp meta tag with connect src to stop it from requesting the destroy endpoint 
16. but this causes an alert which blocks everything, so you put this in an iframe srcdoc that doesnt allow modals
17. do all of this in 30 seconds and you can get the flag! (my solve finishes in 25s with no optimization)
